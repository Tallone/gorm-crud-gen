package handler

import (
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
	"{{.PackageName}}/internal/entity"
	"{{.PackageName}}/internal/service"
	"{{.PackageName}}/internal/http/response"
	"{{.PackageName}}/internal/g/errors"
)

type {{.StructName}}Handler struct {
	service *service.{{.StructName}}Service
}

func New{{.StructName}}Handler(service *service.{{.StructName}}Service) *{{.StructName}}Handler {
	return &{{.StructName}}Handler{service: service}
}

// Create{{.StructName}} godoc
// @Summary Create a new {{.StructName}}
// @Description Create a new {{.StructName}} with the input payload
// @Tags {{.StructName}}
// @Accept json
// @Produce json
// @Param {{.VarName}} body entity.{{.StructName}} true "Create {{.StructName}}"
// @Success 200 {object}  response.Response{data=entity.{{.StructName}}}
// @Router /v1/{{.VarName}}s [post]
func (h *{{.StructName}}Handler) Create{{.StructName}}(c *gin.Context) {
	var {{.VarName}} entity.{{.StructName}}
	if err := c.ShouldBindJSON(&{{.VarName}}); err != nil {
		response.Fail(c, errors.ErrorInvalidRequest)
		return
	}

	if err := h.service.Create(c, &{{.VarName}}); err != nil {
		response.Fail(c, err)
		return
	}

	c.JSON(http.StatusCreated, {{.VarName}})
}

// Get{{.StructName}} godoc
// @Summary Get a {{.StructName}} by ID
// @Description Get a {{.StructName}} by ID
// @Tags {{.StructName}}
// @Accept json
// @Produce json
// @Param id path int true "{{.StructName}} ID"
// @Success 200 {object} response.Response{data=entity.{{.StructName}}}
// @Router /v1/{{.VarName}}s/{id} [get]
func (h *{{.StructName}}Handler) Get{{.StructName}}(c *gin.Context) {
	id, err := strconv.ParseUint(c.Param("id"), 10, 32)
	if err != nil {
		response.Fail(c, errors.ErrorInvalidRequest)
		return
	}

	{{.VarName}}, err := h.service.GetByID(c, uint(id))
	if err != nil {
		response.Fail(c, err)
		return
	}

	c.JSON(http.StatusOK, {{.VarName}})
}

// Update{{.StructName}} godoc
// @Summary Update a {{.StructName}}
// @Description Update a {{.StructName}} with the input payload
// @Tags {{.StructName}}
// @Accept json
// @Produce json
// @Param id path int true "{{.StructName}} ID"
// @Param {{.VarName}} body entity.{{.StructName}} true "Update {{.StructName}}"
// @Success 200 {object} response.Response{data=entity.{{.StructName}}}
// @Router /v1/{{.VarName}}s/{id} [put]
func (h *{{.StructName}}Handler) Update{{.StructName}}(c *gin.Context) {
	id, err := strconv.ParseUint(c.Param("id"), 10, 32)
	if err != nil {
		response.Fail(c, errors.ErrorInvalidRequest)
		return
	}

	var {{.VarName}} entity.{{.StructName}}
	if err := c.ShouldBindJSON(&{{.VarName}}); err != nil {
		response.Fail(c, errors.ErrorInvalidRequest)
		return
	}

	{{.VarName}}.ID = uint(id)
	if err := h.service.Update(c, &{{.VarName}}); err != nil {
		response.Fail(c, err)
		return
	}

	c.JSON(http.StatusOK, {{.VarName}})
}

// Delete{{.StructName}} godoc
// @Summary Delete a {{.StructName}}
// @Description Delete a {{.StructName}} by ID
// @Tags {{.StructName}}
// @Accept json
// @Produce json
// @Param id path int true "{{.StructName}} ID"
// @Success 200 {object} response.Response
// @Router /v1/{{.VarName}}s/{id} [delete]
func (h *{{.StructName}}Handler) Delete{{.StructName}}(c *gin.Context) {
	id, err := strconv.ParseUint(c.Param("id"), 10, 32)
	if err != nil {
		response.Fail(c, errors.ErrorInvalidRequest)
		return
	}

	if err := h.service.Delete(c, uint(id)); err != nil {
		response.Fail(c, err)
		return
	}

	c.Status(http.StatusNoContent)
}

// List{{.StructName}}s godoc
// @Summary List {{.StructName}}s
// @Description Get a list of {{.StructName}}s
// @Tags {{.StructName}}
// @Accept json
// @Produce json
// @Param page query int false "Page number"
// @Param page_size query int false "Page size"
// @Success 200 {object} response.Response{data=[]entity.{{.StructName}}}
// @Router /v1/{{.VarName}}s [get]
func (h *{{.StructName}}Handler) List{{.StructName}}s(c *gin.Context) {
	page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
	pageSize, _ := strconv.Atoi(c.DefaultQuery("page_size", "10"))

	{{.VarName}}s, err := h.service.List(c, page, pageSize)
	if err != nil {
		response.Fail(c, err)
		return
	}

	c.JSON(http.StatusOK, {{.VarName}}s)
}

{{range .Indexes}}
{{if .Unique}}
// Get{{$.StructName}}By{{range $i, $e := .Fields}}{{if $i}}And{{end}}{{$e | title}}{{end}} godoc
// @Summary Get a {{$.StructName}} by {{range $i, $e := .Fields}}{{if $i}} and {{end}}{{$e}}{{end}}
// @Description Get a {{$.StructName}} by {{range $i, $e := .Fields}}{{if $i}} and {{end}}{{$e}}{{end}}
// @Tags {{$.StructName}}
// @Accept json
// @Produce json
{{range .Fields}}
// @Param {{.}} query {{index $.FieldTypes .}} true "{{$.StructName}} {{.}}"
{{end}}
// @Success 200 {object} entity.{{$.StructName}}
// @Router /v1/{{$.VarName}}s/by-{{range $i, $e := .Fields}}{{if $i}}-and{{end}}{{$e | kebab}}{{end}} [get]
func (h *{{$.StructName}}Handler) Get{{$.StructName}}By{{range $i, $e := .Fields}}{{if $i}}And{{end}}{{$e | title}}{{end}}(c *gin.Context) {
	{{range .Fields}}
	{{.}} := c.Query("{{.}}")
	{{end}}

	{{$.VarName}}, err := h.service.GetBy{{range $i, $e := .Fields}}{{if $i}}And{{end}}{{$e | title}}{{end}}(c, {{range $i, $e := .Fields}}{{if $i}}, {{end}}{{$e}}{{end}})
	if err != nil {
		response.Fail(c, err)
		return
	}

	c.JSON(http.StatusOK, {{$.VarName}})
}
{{end}}
{{end}}